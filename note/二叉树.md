# 注意root一定要初始化，不管是初始化成nullptr还是用new初始化，一定不能不写
# 如果只要求层次遍历的话，用数组也可以
```
二叉搜索树（Binary Search Tree，BST）是一种特殊的二叉树数据结构，其中每个节点都满足以下条件：

节点的左子树中的所有节点的值都小于该节点的值。

节点的右子树中的所有节点的值都大于该节点的值。

左子树和右子树也分别是二叉搜索树。

这种结构使得二叉搜索树在查找、插入和删除操作上非常高效，平均时间复杂度为 O(log n)，最坏情况下（树退化为链表）为 O(n)。

生成二叉搜索树的步骤：
给定一组无序整数，以第一个元素为根节点，然后按顺序插入剩余元素：

创建根节点：将序列的第一个整数作为根节点。

插入其他节点：对于序列中的每个剩余整数，从根节点开始比较：

如果整数小于当前节点的值，则进入左子树：

如果左子树为空，则将该整数作为左子节点插入。

如果左子树非空，则递归地在左子树中插入。

如果整数大于或等于当前节点的值，则进入右子树：

如果右子树为空，则将该整数作为右子节点插入。

如果右子树非空，则递归地在右子树中插入。

  遍历方式：
1. 中序遍历：先遍历左子树，然后访问根节点，最后遍历右子树。对于二叉搜索树，中序遍历会得到升序序列。

2. 先序遍历：先访问根节点，然后遍历左子树，最后遍历右子树。先序遍历反映了节点的插入顺序。
```

# 二叉搜索树建立
```python
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

TreeNode* insert(TreeNode* root, int value) {
    if (root == NULL) {
        return new TreeNode(value);
    }
    if (value < root->val) {
        root->left = insert(root->left, value);
    } else {
        root->right = insert(root->right, value);
    }
    return root;
}

void inorder(TreeNode* root, vector<int>& result) {
    if (root == NULL) return;
    inorder(root->left, result);
    result.push_back(root->val);
    inorder(root->right, result);
}

void preorder(TreeNode* root, vector<int>& result) {
    if (root == NULL) return;
    result.push_back(root->val);
    preorder(root->left, result);
    preorder(root->right, result);
}
```

```python
如何实现层次遍历？
层次遍历通常使用队列（Queue） 数据结构来实现，算法步骤如下：

将根节点加入队列

当队列不为空时：

记录当前队列的大小（即当前层的节点数）

依次从队列中取出当前层的所有节点，并访问它们

将每个取出节点的左右子节点（如果存在）加入队列

重复步骤2直到队列为空

实现示例（C++）
    
    // 层次遍历
    queue<int> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size(); // 当前层的节点数
        
        for (int i = 0; i < levelSize; i++) {
            int node = q.front();
            q.pop();
            
            // 将子节点加入队列
            if (left[node] != 0) {
                pass
            }
            if (right[node] != 0) {
                pass
            }
        }
    }
    
算法解析
寻找根节点：通过标记所有有父节点的节点，找到没有父节点的根节点

使用队列：队列确保节点按层级顺序处理

记录层级大小：在每层开始前记录队列大小，确保只处理当前层的节点

输出格式：

同一层节点间用空格分隔

不同层间用换行符分隔

这种实现方式的时间复杂度是O(n)，空间复杂度也是O(n)，能够高效处理题目中给出的约束条件（n ≤ 10^5）。
```

# 层次遍历
``` c++
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 层次遍历函数
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (root == nullptr) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> currentLevel;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node->val);
            
            if (node->left != nullptr) {
                q.push(node->left);
            }
            if (node->right != nullptr) {
                q.push(node->right);
            }
        }
        result.push_back(currentLevel);
    }
    
    return result;
}
}
```

# 先序和中序重建二叉树
```

// 根据前序和中序遍历重建二叉树
TreeNode* buildTree(string preorder, string inorder) {
    if (preorder.empty() || inorder.empty()) {
        return nullptr;
    }
    
    // 前序遍历的第一个元素是根节点
    char rootVal = preorder[0];
    TreeNode* root = new TreeNode(rootVal);
    
    // 在中序遍历中找到根节点的位置
    int rootIndex = inorder.find(rootVal);
    
    // 分割中序遍历序列
    string leftInorder = inorder.substr(0, rootIndex);
    string rightInorder = inorder.substr(rootIndex + 1);
    
    // 分割前序遍历序列
    string leftPreorder = preorder.substr(1, leftInorder.length());
    string rightPreorder = preorder.substr(1 + leftInorder.length());
    
    // 递归重建左右子树
    root->left = buildTree(leftPreorder, leftInorder);
    root->right = buildTree(rightPreorder, rightInorder);
    
    return root;
}
```

# 二叉树的内存清理一般采用后序遍历

# 对称二叉树，比较左节点和右节点，然后比较左左右右和右右左左

# 哈夫曼树
```
算法原理
1. 哈夫曼树构建过程
哈夫曼树的构建基于贪心策略：
每次选择权值最小的两个节点
合并它们，形成一个新的节点，权值为这两个节点权值之和
将新节点放回候选集中
注意新节点只是一个内部节点，不要输出它

重复上述过程，直到只剩一个节点

2. 为什么这样能得到最优解
在最优二叉树中，权值越大的叶子节点应该离根节点越近，权值越小的叶子节点应该离根节点越远。通过每次合并最小的两个节点，我们确保了权值大的节点在合并过程中被合并的次数较少，从而离根节点更近。

3. 总权值计算
在构建过程中，每次合并两个节点时，新节点的权值会被多次计算：

在后续的合并中，这个新节点可能再次被合并

因此，每次合并产生的权值之和就是最终的总权值

算法步骤详解
初始化：将所有叶子节点的权值放入最小堆

循环合并：

从堆中取出两个最小的权值

计算它们的和

将这个和加入总权值

将这个和放回堆中

终止条件：当堆中只剩一个元素时，结束循环

输出结果：输出累计的总权值

时间复杂度分析
每次插入和删除堆顶元素的时间复杂度为O(log n)

总共需要进行n-1次合并操作

总时间复杂度为O(n log n)，满足题目要求
```
```python
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    // 使用最小堆（优先队列）
    priority_queue<long long, vector<long long>, greater<long long>> pq;
    
    // 读取所有权值并加入优先队列
    for (int i = 0; i < n; i++) {
        long long w;
        cin >> w;
        pq.push(w);
    }
    
    long long total = 0;
    
    // 当队列中不止一个元素时，持续合并
    while (pq.size() > 1) {
        // 取出两个最小的元素
        long long a = pq.top(); pq.pop();
        long long b = pq.top(); pq.pop();
        
        // 合并这两个节点，新节点的权值为a+b
        long long sum = a + b;
        
        // 将新节点加入队列
        pq.push(sum);
        
        // 累加到总权值
        total += sum;
    }
    
    cout << total << endl;
    
    return 0;
}
```

# 多叉树与二叉树
```
struct TreeNode {
    int id;
    vector<TreeNode*> children;  // 多叉树的孩子列表
    TreeNode* left;              // 二叉树的左儿子（第一个孩子）
    TreeNode* right;             // 二叉树的右兄弟（下一个兄弟）
    
    TreeNode(int i) : id(i), left(nullptr), right(nullptr) {}
};

// 构建多叉树
TreeNode* buildMultiTree(int n, vector<int>& parents) {
    vector<TreeNode*> nodes(n + 1);
    
    // 创建所有节点
    for (int i = 1; i <= n; i++) {
        nodes[i] = new TreeNode(i);
    }
    
    // 建立父子关系
    for (int i = 2; i <= n; i++) {
        int parent = parents[i];
        nodes[parent]->children.push_back(nodes[i]);
    }
    
    // 对每个节点的孩子按编号排序
    for (int i = 1; i <= n; i++) {
        sort(nodes[i]->children.begin(), nodes[i]->children.end(), 
             [](TreeNode* a, TreeNode* b) { return a->id < b->id; });
    }
    
    return nodes[1];  // 返回根节点
}

// 将多叉树转为左儿子右兄弟二叉树
void convertToBinaryTree(TreeNode* root) {
    if (!root) return;
    
    // 如果有孩子，左儿子指向第一个孩子
    if (!root->children.empty()) {
        root->left = root->children[0];
        
        // 建立兄弟链
        for (size_t i = 0; i + 1 < root->children.size(); i++) {
            root->children[i]->right = root->children[i + 1];
        }
    }
    
    // 递归处理所有孩子
    for (TreeNode* child : root->children) {
        convertToBinaryTree(child);
    }
}
```
