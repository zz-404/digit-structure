# 注意root一定要初始化，不管是初始化成nullptr还是用new初始化，一定不能不写
```
二叉搜索树（Binary Search Tree，BST）是一种特殊的二叉树数据结构，其中每个节点都满足以下条件：

节点的左子树中的所有节点的值都小于该节点的值。

节点的右子树中的所有节点的值都大于该节点的值。

左子树和右子树也分别是二叉搜索树。

这种结构使得二叉搜索树在查找、插入和删除操作上非常高效，平均时间复杂度为 O(log n)，最坏情况下（树退化为链表）为 O(n)。

生成二叉搜索树的步骤：
给定一组无序整数，以第一个元素为根节点，然后按顺序插入剩余元素：

创建根节点：将序列的第一个整数作为根节点。

插入其他节点：对于序列中的每个剩余整数，从根节点开始比较：

如果整数小于当前节点的值，则进入左子树：

如果左子树为空，则将该整数作为左子节点插入。

如果左子树非空，则递归地在左子树中插入。

如果整数大于或等于当前节点的值，则进入右子树：

如果右子树为空，则将该整数作为右子节点插入。

如果右子树非空，则递归地在右子树中插入。

  遍历方式：
1. 中序遍历：先遍历左子树，然后访问根节点，最后遍历右子树。对于二叉搜索树，中序遍历会得到升序序列。

2. 先序遍历：先访问根节点，然后遍历左子树，最后遍历右子树。先序遍历反映了节点的插入顺序。
```

# 二叉搜索树建立
```python
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

TreeNode* insert(TreeNode* root, int value) {
    if (root == NULL) {
        return new TreeNode(value);
    }
    if (value < root->val) {
        root->left = insert(root->left, value);
    } else {
        root->right = insert(root->right, value);
    }
    return root;
}

void inorder(TreeNode* root, vector<int>& result) {
    if (root == NULL) return;
    inorder(root->left, result);
    result.push_back(root->val);
    inorder(root->right, result);
}

void preorder(TreeNode* root, vector<int>& result) {
    if (root == NULL) return;
    result.push_back(root->val);
    preorder(root->left, result);
    preorder(root->right, result);
}
```

```python
如何实现层次遍历？
层次遍历通常使用队列（Queue） 数据结构来实现，算法步骤如下：

将根节点加入队列

当队列不为空时：

记录当前队列的大小（即当前层的节点数）

依次从队列中取出当前层的所有节点，并访问它们

将每个取出节点的左右子节点（如果存在）加入队列

重复步骤2直到队列为空

实现示例（C++）
    
    // 层次遍历
    queue<int> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size(); // 当前层的节点数
        
        for (int i = 0; i < levelSize; i++) {
            int node = q.front();
            q.pop();
            
            // 将子节点加入队列
            if (left[node] != 0) {
                pass
            }
            if (right[node] != 0) {
                pass
            }
        }
    }
    
算法解析
寻找根节点：通过标记所有有父节点的节点，找到没有父节点的根节点

使用队列：队列确保节点按层级顺序处理

记录层级大小：在每层开始前记录队列大小，确保只处理当前层的节点

输出格式：

同一层节点间用空格分隔

不同层间用换行符分隔

这种实现方式的时间复杂度是O(n)，空间复杂度也是O(n)，能够高效处理题目中给出的约束条件（n ≤ 10^5）。
```

# 层次遍历
``` c++
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

// 二叉树节点定义
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 层次遍历函数
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (root == nullptr) return result;
    
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> currentLevel;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node->val);
            
            if (node->left != nullptr) {
                q.push(node->left);
            }
            if (node->right != nullptr) {
                q.push(node->right);
            }
        }
        result.push_back(currentLevel);
    }
    
    return result;
}
}
```

# 先序和中序重建二叉树
```

// 根据前序和中序遍历重建二叉树
TreeNode* buildTree(string preorder, string inorder) {
    if (preorder.empty() || inorder.empty()) {
        return nullptr;
    }
    
    // 前序遍历的第一个元素是根节点
    char rootVal = preorder[0];
    TreeNode* root = new TreeNode(rootVal);
    
    // 在中序遍历中找到根节点的位置
    int rootIndex = inorder.find(rootVal);
    
    // 分割中序遍历序列
    string leftInorder = inorder.substr(0, rootIndex);
    string rightInorder = inorder.substr(rootIndex + 1);
    
    // 分割前序遍历序列
    string leftPreorder = preorder.substr(1, leftInorder.length());
    string rightPreorder = preorder.substr(1 + leftInorder.length());
    
    // 递归重建左右子树
    root->left = buildTree(leftPreorder, leftInorder);
    root->right = buildTree(rightPreorder, rightInorder);
    
    return root;
}
```

# 二叉树的内存清理一般采用后序遍历

# 对称二叉树，比较左节点和右节点，然后比较左左右右和右右左左
