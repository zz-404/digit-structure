```
二叉搜索树（Binary Search Tree，BST）是一种特殊的二叉树数据结构，其中每个节点都满足以下条件：

节点的左子树中的所有节点的值都小于该节点的值。

节点的右子树中的所有节点的值都大于该节点的值。

左子树和右子树也分别是二叉搜索树。

这种结构使得二叉搜索树在查找、插入和删除操作上非常高效，平均时间复杂度为 O(log n)，最坏情况下（树退化为链表）为 O(n)。

生成二叉搜索树的步骤：
给定一组无序整数，以第一个元素为根节点，然后按顺序插入剩余元素：

创建根节点：将序列的第一个整数作为根节点。

插入其他节点：对于序列中的每个剩余整数，从根节点开始比较：

如果整数小于当前节点的值，则进入左子树：

如果左子树为空，则将该整数作为左子节点插入。

如果左子树非空，则递归地在左子树中插入。

如果整数大于或等于当前节点的值，则进入右子树：

如果右子树为空，则将该整数作为右子节点插入。

如果右子树非空，则递归地在右子树中插入。

  遍历方式：
1. 中序遍历：先遍历左子树，然后访问根节点，最后遍历右子树。对于二叉搜索树，中序遍历会得到升序序列。

2. 先序遍历：先访问根节点，然后遍历左子树，最后遍历右子树。先序遍历反映了节点的插入顺序。
```


```python
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

TreeNode* insert(TreeNode* root, int value) {
    if (root == NULL) {
        return new TreeNode(value);
    }
    if (value < root->val) {
        root->left = insert(root->left, value);
    } else {
        root->right = insert(root->right, value);
    }
    return root;
}

void inorder(TreeNode* root, vector<int>& result) {
    if (root == NULL) return;
    inorder(root->left, result);
    result.push_back(root->val);
    inorder(root->right, result);
}

void preorder(TreeNode* root, vector<int>& result) {
    if (root == NULL) return;
    result.push_back(root->val);
    preorder(root->left, result);
    preorder(root->right, result);
}
```
