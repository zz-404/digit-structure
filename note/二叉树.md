```
二叉搜索树（Binary Search Tree，BST）是一种特殊的二叉树数据结构，其中每个节点都满足以下条件：

节点的左子树中的所有节点的值都小于该节点的值。

节点的右子树中的所有节点的值都大于该节点的值。

左子树和右子树也分别是二叉搜索树。

这种结构使得二叉搜索树在查找、插入和删除操作上非常高效，平均时间复杂度为 O(log n)，最坏情况下（树退化为链表）为 O(n)。

生成二叉搜索树的步骤：
给定一组无序整数，以第一个元素为根节点，然后按顺序插入剩余元素：

创建根节点：将序列的第一个整数作为根节点。

插入其他节点：对于序列中的每个剩余整数，从根节点开始比较：

如果整数小于当前节点的值，则进入左子树：

如果左子树为空，则将该整数作为左子节点插入。

如果左子树非空，则递归地在左子树中插入。

如果整数大于或等于当前节点的值，则进入右子树：

如果右子树为空，则将该整数作为右子节点插入。

如果右子树非空，则递归地在右子树中插入。

  遍历方式：
1. 中序遍历：先遍历左子树，然后访问根节点，最后遍历右子树。对于二叉搜索树，中序遍历会得到升序序列。

2. 先序遍历：先访问根节点，然后遍历左子树，最后遍历右子树。先序遍历反映了节点的插入顺序。
```


```python
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

TreeNode* insert(TreeNode* root, int value) {
    if (root == NULL) {
        return new TreeNode(value);
    }
    if (value < root->val) {
        root->left = insert(root->left, value);
    } else {
        root->right = insert(root->right, value);
    }
    return root;
}

void inorder(TreeNode* root, vector<int>& result) {
    if (root == NULL) return;
    inorder(root->left, result);
    result.push_back(root->val);
    inorder(root->right, result);
}

void preorder(TreeNode* root, vector<int>& result) {
    if (root == NULL) return;
    result.push_back(root->val);
    preorder(root->left, result);
    preorder(root->right, result);
}
```

```
如何实现层次遍历？
层次遍历通常使用队列（Queue） 数据结构来实现，算法步骤如下：

将根节点加入队列

当队列不为空时：

记录当前队列的大小（即当前层的节点数）

依次从队列中取出当前层的所有节点，并访问它们

将每个取出节点的左右子节点（如果存在）加入队列

重复步骤2直到队列为空

实现示例（C++）
cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main() {
    int n;
    cin >> n;
    
    vector<int> left(n + 1), right(n + 1);
    vector<bool> hasParent(n + 1, false);
    
    // 读取输入并构建树结构
    for (int i = 1; i <= n; i++) {
        cin >> left[i] >> right[i];
        if (left[i] != 0) hasParent[left[i]] = true;
        if (right[i] != 0) hasParent[right[i]] = true;
    }
    
    // 寻找根节点（没有父节点的节点）
    int root = 0;
    for (int i = 1; i <= n; i++) {
        if (!hasParent[i]) {
            root = i;
            break;
        }
    }
    
    // 层次遍历
    queue<int> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size(); // 当前层的节点数
        
        for (int i = 0; i < levelSize; i++) {
            int node = q.front();
            q.pop();
            
            // 输出当前节点
            cout << node;
            if (i < levelSize - 1) {
                cout << " "; // 同一层节点间用空格分隔
            }
            
            // 将子节点加入队列
            if (left[node] != 0) {
                q.push(left[node]);
            }
            if (right[node] != 0) {
                q.push(right[node]);
            }
        }
        cout << endl; // 一层结束后换行
    }
    
    return 0;
}
算法解析
寻找根节点：通过标记所有有父节点的节点，找到没有父节点的根节点

使用队列：队列确保节点按层级顺序处理

记录层级大小：在每层开始前记录队列大小，确保只处理当前层的节点

输出格式：

同一层节点间用空格分隔

不同层间用换行符分隔

这种实现方式的时间复杂度是O(n)，空间复杂度也是O(n)，能够高效处理题目中给出的约束条件（n ≤ 10^5）。
```
