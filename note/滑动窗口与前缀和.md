# 滑动窗口
**子串问题（连续结构）优先考虑滑动窗口和前缀和，这里使用滑动窗口求解**

**何时想到用滑动窗口？   
当问题具有以下特征时：  
涉及数组/字符串中的连续子序列  
要求找到最大/最小长度、特定和、包含某些元素等   
暴力解法需要多重循环
滑动窗口的优势在于利用先前计算的结果，但回文验证的结果很难在窗口滑动时被有效复用。  
滑动窗口适用于解决连续且具有单调性的问题（如「无重复字符」）**
模板：  
```C++
//外层循环扩展右边界，内层循环扩展左边界
for (int l = 0, r = 0 ; r < n ; r++) {
	//当前考虑的元素
	while (l <= r && check()) {//区间[left,right]不符合题意
        //扩展左边界
    }
    //区间[left,right]符合题意，统计相关信息
}
```
**滑动窗口一般要先填满窗口，完全可以用i=0，i++；i+len来访问**  
**for(int i=0;i+p.length()<s.length();i++){        },i是要丢弃的元素，i+p.length是要扩展的元素**
**或者老老实实for (int i = k; i < n; ++i)访问**
**！！！滑动窗口主要解决的是如果一个序列不合题意，那么向右扩展之后也一定不符合题意的问题，如果有的时候一个组合不合题意但向右扩展之后就合题了，那么不能使用滑动窗口**

经典吃糖果例题：
```
#include<iostream>
#include<cmath>
using namespace std;
int arr[200005] = { 0 };

int main() {
  
	int n; int m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}

	int maxsize = 0;
	int tot = 0;
	for (int l = 0, r = 0; r < n; r++) {
		tot += arr[r];
		while (l <= r && tot > m) {
			tot-=arr[l++];
		}
		maxsize = max(maxsize, r - l + 1);
	}
	cout << maxsize;
}
```

# 前缀和
注意前缀和无法解决左右元素相等时该删去哪个的问题，换言之无法解决求最大或最小长度的问题，因为他不知道两边元素相同时删掉哪个会更加符合题意
**前缀和数组不一定是递增的，尤其是出现负数的时候**  
```
forw[0]=0;
for(int i=0;i<nums.size();i++){
	forw[i+1]=forw[i]+nums[i];
}

for(int i=0;i<forw.size();i++){
	for(int j=i+1;j<forw.size();j++){
		if(forw[j]-forw[i]==k&&j>i){
			ans++;
		}
	}
}
```
**num[r] - num [l] = [ l , r ) 实际上是左闭右开的区间**

**如果用二重循环暴力枚举有多少个 s[j]−s[i]=k，时间复杂度是 O(n^2)，太慢了。如何加速？
我们可以把 s[j]−s[i]=k 移项，得
s[i]=s[j]−k
遍历 s，一边枚举右边的 j，一边用哈希表统计左边有多少个 i 满足 i<j 且 s[i]=s[j]−k。
比如 s[j]=2，那么 s[i]=s[j]−k=2−1=1，我们要找的是 j 左边有多少个 s[i]=1。在上面的例子中，遍历到 s[4]=2 时，我们知道左边有 2 个 s[i]=1，所以新找到了 2 个和为 1 的子数组。
用这个视角，再来算算上图中的那 6 个和为 1 的子数组。**
