### 注意事项
一定是要node* current，不要忘记星号
头插法
```
node *head=nullptr,*tail = nullptr;

node *newnode= new node(0)

必须分配内存，分配好内存之后再去操作或者更改数字
```

分配内存和插入是主干，中间的修改元素才是分支,甚至可以利用哑节点直接实现tail->next= new node(a),**tail=tail -> next**
尽量不要循环套循环，每次就插一个！！！

不用==nullptr也是可以的
## 使用哑节点
```
struct Node {
    int val;
    Node* next;
};

// 创建哑节点
Node dummy(0);  // 值可以是任意值，通常用0
// 或者
Node *tail=&dummy
```
```
Node* addNode(Node* head, int value) {
    Node dummy(0);
    dummy.next = head;  // 哑节点指向原链表
    
    Node* tail = &dummy;
    while (tail->next != nullptr) {
        tail = tail->next;
    }
    
    tail->next = new Node(value);
    return dummy.next;  // 返回真正的头节点
}
```
合并两个有序链表
```
// 使用哑节点（更简洁）
Node* mergeLists(Node* a, Node* b) {
    Node dummy(0);
    Node* tail = &dummy;
    
    while (a && b) {
        if (a->val <= b->val) {
            tail->next = a;
            a = a->next;
        } else {
            tail->next = b;
            b = b->next;
        }
        tail = tail->next;
    }
    tail->next = a ? a : b;
    return dummy.next;
}
```

关键理解：delete 释放的是内存，不是指针变量本身

```
链表求和
#include<List.h>
#include<iostream>
using namespace std;
// 方法1：反转链表后相加（推荐）
Node* getSum(Node* a, Node* b) {
    if (!a) return b;
    if (!b) return a;
    
    // 反转两个链表（从个位开始相加）
    auto reverseList = [](Node* head) -> Node* {
        Node* prev = nullptr;
        Node* curr = head;
        while (curr) {
            Node* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    };
    
    Node* l1 = reverseList(a);
    Node* l2 = reverseList(b);
    
    Node* dummy = new Node(0);
    Node* current = dummy;
    int carry = 0;
    
    while (l1 || l2 || carry) {
        int sum = carry;
        if (l1) {
            sum += l1->value;
            l1 = l1->next;
        }
        if (l2) {
            sum += l2->value;
            l2 = l2->next;
        }
        
        carry = sum / 10;
        current->next = new Node(sum % 10);
        current = current->next;
    }
    
    // 反转结果链表恢复原始顺序
    Node* result = reverseList(dummy->next);
    delete dummy;
    return result;
}
```
**非常关键，反复学习思想**


不创建的合并有序链表
```
#include <iostream>
using namespace std;

Node* orderly_merge_list(Node* a, Node* b) {
    // 处理空链表情况
    if (!a) return b;
    if (!b) return a;
    
    // 确定头节点（较小的作为头）
    Node* head = nullptr;
    if (a->val <= b->val) {
        head = a;
        a = a->next;
    } else {
        head = b;
        b = b->next;
    }
    
    Node* current = head;
    
    // 合并两个链表
    while (a && b) {
        if (a->val <= b->val) {
            current->next = a;
            a = a->next;
        } else {
            current->next = b;
            b = b->next;
        }
        current = current->next;
    }
    
    // 连接剩余部分
    if (a) {
        current->next = a;
    } else {
        current->next = b;
    }
    
    return head;
}
```
123
哑节点优化版本：
```
#include <iostream>
#include<node.h>
using namespace std;

Node* orderly_merge_list(Node* a, Node* b) {
    Node dummy(0);
    Node *tail=&dummy;

    while(a||b){
        if(a && b && a->val <= b->val){
            tail ->next=a;
            tail = tail->next;
            a= a->next;
        }else if(a &&b && a->val > b->val){
            tail ->next=b;
            tail = tail->next;
            b= b->next;
        }else if(a){
            tail ->next=a;
            tail = tail->next;
            a= a->next;
        }else{
            tail ->next=b;
            tail = tail->next;
            b= b->next;
        }
    }
    return dummy.next;
}
```

