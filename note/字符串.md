## 求最长回文串
**考虑中心扩展**

## KMP算法
```
    //计算next数组
    vector<int> next(tar.length());
    next[0]=0;

    for(int i=1,j=0;i<tar.length();i++){
        while(j>0&&tar[i]!=tar[j]){
            j=next[j-1];
        }
        if(tar[i]==tar[j]){
            j++;
        }
        next[i]=j;
    }

    //KMP
    for(int i=0,j=0;i<des.length();i++){
        while(j>0&&des[i]!=tar[j]){
            j=next[j-1];
        }
        if(des[i]==tar[j]){
            j++;
        }
        if(j==tar.length()){
            j=next[j-1];
            index.push_back(i-tar.length()+1);
            ans++;
        }
    }
```

## 最长公共子串
关键思路是：当我们比较s1[i]和s2[j]时：

如果它们相等，那么以s1[i]和s2[j]结尾的公共子串长度 = 以s1[i-1]和s2[j-1]结尾的公共子串长度 + 1

如果它们不相等，那么以s1[i]和s2[j]结尾的公共子串长度 = 0

string也是可以用push_back和pop_back的

```
substr(start, length)
