# 哈希表 ( unordered_map )
## 优势
1. 查找操作的复杂度仅为o(1),注意，**针对字符串的查找操作也是相同的 o(1) !!!**
2. 键值存储，因而也可以返回索引
3. 可以储存指针，对于位置数据也是可以使用的
4. 有多个元素都相同时，考虑利用哈希表来存放相同元素的出现个数
**涉及到要用双层循环来枚举合法条件的，可以考虑用移项后枚举再哈希的形式优化**
**注意umap的配对是任意的，需要打开思路**  
## 详细实现
1. 头文件 #include <unordered_map>
2. 初始化
```
#include <unordered_map>  // 包含哈希表头文件
#include <unordered_set>   // 包含哈希集合头文件

// 初始化方式
unordered_map<int, string> map1;  // 空哈希表
unordered_map<string, int> map2 = {{"apple", 1}, {"banana", 2}};
unordered_set<int> set1 = {1, 2, 3, 4, 5};
```
**注意元素是双大括号**
3. 操作细节
- 插入
```c++
unordered_map<string, int> umap;

// 插入键值对 - 方法1
umap.insert({"apple", 1});

// 使用[]操作符插入/修改
umap["orange"] = 3;     // 插入新键
umap["apple"] = 10;     // 修改已存在的键
umap["apple"]++;
// 批量插入
umap.insert({{"grape", 4}, {"mango", 5}});

//哈希集合
unordered_set<int> us;
us.insert(10);
```
**umap[temp] = i;也是插入的操作  // 使用[]，会更新重复键的索引**  
**注意uset并不支持uset[a]的操作且uset对部分数据类型例如vector还不适配**
**注意不能通过.begin().end()来插入或初始化**
- 查找
// 查找键是否存在
```
if (umap.find("apple") != umap.end()) {
    cout << "找到apple" << endl;
}

或者
umap.count(key)

二者的区别在于find返回一个迭代器，可以操作，而count只返回有或者没有！！！
```
**注意find返回的是一个指针**
- 删除
```
// 删除迭代器指向的元素
auto it = umap.find("banana");
if (it != umap.end()) {
    umap.erase(it);
}

// 删除多个元素
1.按指针删除
umap.erase(it); 

2.按键或者按值删除
umap.erase(“banana”);
uset.erase(3)
umap["banana"]--;
umap["banana"]=0;
// 清空哈希表
umap.clear();
```
- 遍历
```
// 方法1：使用迭代器
for (auto it = umap.begin(); it != umap.end(); ++it) {
    cout << it->first << ": " << it->second << endl;
}

```
**注意first不加括号的啊**  

**当数组中有重复元素时，insert 不会更新已存在的键值对，而是保留第一次插入的值。**  

**或者使用umap[''apple'']直接访问值，但通常要检查一下有没有该键，防止意外创建**

# 实践
```
P49 字母异位词
合理设计的哈希键能够有效地整合原始信息，找出对于解题有用的结果信息
常见哈希键设计：

在字符串和数组当中，当每个元素的顺序不重要时，可以使用排序后的字符串或数组作为键
如果只关心每个值的偏移量，例如第一个值的偏移量，则可以使用偏移量作为键
在树中，我们通常会用子树的序列化表述作为键
```


set会严格检查vector中元素的顺序，顺序不同的不被视为同一个元素  
**但是哈希表unordered_map并没有提供针对vector<int> 的实现**
```
在C++中，不能直接将vector用作unordered_map的键，因为unordered_map要求键类型必须是可哈希的，而标准库没有为vector提供默认的哈希函数。

问题原因
unordered_map使用哈希表实现，需要键类型满足：

可哈希：有对应的std::hash特化

可比较相等：有operator==

标准库没有为vector提供std::hash特化。
```

```
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;
        for (string& str: strs) {
            string key = str;
            sort(key.begin(), key.end());
            ！！！！ mp[key].emplace_back(str);
        }
        vector<vector<string>> ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            ans.emplace_back(it->second);
        }
        return ans;
    }
};
```
请注意，插入或创建可以直接使用mp[key]来完成，如果不存在的话也是会自动创建的！！！


# uset

1. 插入元素
cpp
unordered_set<int> uset;

// insert() - 插入元素，返回pair<iterator, bool>
auto result = uset.insert(5);  // 插入5
if (result.second) {
    cout << "插入成功" << endl;
}

// emplace() - 原地构造元素，效率更高
uset.emplace(10);  // 插入10

2. 查找元素
cpp
// find() - 查找元素，返回迭代器
auto it = uset.find(5);
if (it != uset.end()) {
    cout << "找到元素: " << *it << endl;
}

// count() - 返回元素数量（0或1）
if (uset.count(5)) {
    cout << "元素存在" << endl;
}
3. 删除元素
cpp
// erase() - 删除元素
uset.erase(5);           // 通过值删除
uset.erase(it);          // 通过迭代器删除
uset.erase(uset.begin(), uset.end());  // 删除范围

// clear() - 清空所有元素
uset.clear();
4. 容量查询
cpp
// size() - 返回元素数量
cout << "元素个数: " << uset.size() << endl;

// empty() - 判断是否为空
if (uset.empty()) {
    cout << "集合为空" << endl;
}

// max_size() - 返回最大可能元素数量
cout << "最大容量: " << uset.max_size() << endl;
迭代器相关

# 查找最大相同字串
```
// 从大到小枚举长度，这个思路很关键！！！
    for (int length = n - 1; length > 0; length--) {
        unordered_map<string, int> seen;
        for (int i = 0; i <= n - length; i++) {
            string sub = s.substr(i, length);
            if (seen.find(sub) != seen.end()) {
                // 允许重叠，只要起始位置不同
                    return length;
                
            } else {
                seen[sub] = i;
            }
        }
    }
```
