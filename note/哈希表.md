# 哈希表 ( unordered_map )
## 优势
1. 查找操作的复杂度仅为o(1)
2. 键值存储，因而也可以返回索引
**注意umap的配对是任意的，需要打开思路**  
## 详细实现
1. 头文件 #include <unordered_map>
2. 初始化
```
#include <unordered_map>  // 包含哈希表头文件
#include <unordered_set>   // 包含哈希集合头文件

// 初始化方式
unordered_map<int, string> map1;  // 空哈希表
unordered_map<string, int> map2 = {{"apple", 1}, {"banana", 2}};
unordered_set<int> set1 = {1, 2, 3, 4, 5};
```
**注意元素是双大括号**
3. 操作细节
- 插入
```c++
unordered_map<string, int> umap;

// 插入键值对 - 方法1
umap.insert({"apple", 1});

// 使用[]操作符插入/修改
umap["orange"] = 3;     // 插入新键
umap["apple"] = 10;     // 修改已存在的键

// 批量插入
umap.insert({{"grape", 4}, {"mango", 5}});

//哈希集合
unordered_set<int> us;
us.insert(10);
```
**umap[temp] = i;也是插入的操作  // 使用[]，会更新重复键的索引**
- 查找
// 查找键是否存在
```
if (umap.find("apple") != umap.end()) {
    cout << "找到apple" << endl;
}

```
**注意find返回的是一个指针**
- 删除
```
// 删除迭代器指向的元素
auto it = umap.find("banana");
if (it != umap.end()) {
    umap.erase(it);
}

// 删除多个元素
umap.erase(umap.begin(), next(umap.begin(), 2));  // 删除前两个元素

// 清空哈希表
umap.clear();
```
- 遍历
```
// 方法1：使用迭代器
for (auto it = umap.begin(); it != umap.end(); ++it) {
    cout << it->first << ": " << it->second << endl;
}

```
**注意first不加括号的啊**  

**当数组中有重复元素时，insert 不会更新已存在的键值对，而是保留第一次插入的值。**  

**或者使用umap[''apple'']直接访问值，但通常要检查一下有没有该键，防止意外创建**

# 实践
```
P49 字母异位词
合理设计的哈希键能够有效地整合原始信息，找出对于解题有用的结果信息
常见哈希键设计：

在字符串和数组当中，当每个元素的顺序不重要时，可以使用排序后的字符串或数组作为键
如果只关心每个值的偏移量，例如第一个值的偏移量，则可以使用偏移量作为键
在树中，我们通常会用子树的序列化表述作为键
```
