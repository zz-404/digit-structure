# 栈的特性
- 可以实现配对相消，如果这样的话后面就不会再看到这一项
- 只有两个操作入和出，可以作为判断符合栈序列是否合法的条件

```
题目描述
将中缀表达式（infix expression）转换为后缀表达式（postfix expression）。假设中缀表达式中的操作数均以单个英文字母表示，且其中只包含左括号'('，右括号‘)’和双目算术操作符+，-，*， /。

输入描述
表示中缀表达式的一个字符串（其中只包含操作数和操作符和左右括号，不包含任何其他字符），长度不超过100个字符。

输出描述
对应后缀表达式字符串（其中只包含操作数和操作符，不包含任何其他字符）

样例输入
A+B*C-D-E/F

a+(b-c)*d+e/f

样例输出
ABC*+D-EF/-

abc-d*+ef/+


#include<iostream>
#include<stack>
using namespace std;

//栈的特性，匹配之后配对之后消去后面就不会再注意到这个项
//加减负责清空前面到括号处的一整项，这样的话乘除就是先被清空的，
//反括号和正括号负责清空内部项
int main(){
    string a;
    cin>>a;
    string ans="";
    stack<char> tok;
    int flag=0;
    for(int i=0;i<a.length();i++){

        if(a[i]=='('){
            tok.push(a[i]);
            flag++;
        }else if(a[i]==')'){
            while(tok.top()!='('){
                ans+=tok.top();
                tok.pop();
            }
            tok.pop();
            flag--;
        }else if(a[i]>='A'&&a[i]<='Z'||a[i]>='a'&&a[i]<='z'){
            ans+=a[i];
        }else if(a[i]=='*'||a[i]=='/'){
            tok.push(a[i]);
        }else if(a[i]=='+'||a[i]=='-'){
            while(!tok.empty()){
                if(tok.top()=='('){
                    break;
                }else{
                    ans+=tok.top();
                    tok.pop();
                }    
            }
            tok.push(a[i]);
        }
    }
    while(!tok.empty()){
        ans+=tok.top();
        tok.pop();
    }
    cout<<ans;
}
```
```
#include <iostream>
#include <stack>
#include <string>
#include <cctype>

using namespace std;

// 获取操作符优先级
int getPriority(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;  // 其他字符（如括号）
}

// 中缀转后缀函数
string infixToPostfix(const string& infix) {
    stack<char> operators;
    string postfix = "";
    
    for (char ch : infix) {
        if (isalpha(ch)) {  // 操作数直接输出
            postfix += ch;
        }
        else if (ch == '(') {  // 左括号入栈
            operators.push(ch);
        }
        else if (ch == ')') {  // 右括号：弹出直到左括号
            while (!operators.empty() && operators.top() != '(') {
                postfix += operators.top();
                operators.pop();
            }
            operators.pop();  // 弹出左括号
        }
        else {  // 操作符
            while (!operators.empty() && 
                   getPriority(operators.top()) >= getPriority(ch) && 
                   operators.top() != '(') {
                postfix += operators.top();
                operators.pop();
            }
            operators.push(ch);
        }
    }
    
    // 弹出栈中剩余的操作符
    while (!operators.empty()) {
        postfix += operators.top();
        operators.pop();
    }
    
    return postfix;
}

int main() {
    string infix;
    
    while (getline(cin, infix)) {
        string postfix = infixToPostfix(infix);
        cout << postfix << endl;
    }
    
    return 0;
}
```
**deepseek的方法更加合理，设置了优先级，每次处理都把之前的优先级高的东西处理完毕，同时由于每项相消可以**

注意对栈操作时尽量不要用size（）作为循环条件因为size()是一直变化的

在求卡塔兰数问题时，可以利用出栈入栈的方式检验某个序列是否合法

# 单调栈：
单调栈深度解析：机理与适用场景
什么是单调栈？
单调栈是一种特殊的栈结构，栈中的元素保持单调性（递增或递减）。它主要用于解决"下一个更大/更小元素"这类边界查找问题。

核心机理
1. 单调性维护
cpp
// 单调递增栈（栈底到栈顶递增）
stack<int> st;
for (int i = 0; i < n; i++) {
    while (!st.empty() && arr[st.top()] > arr[i]) {
        // 弹出破坏单调性的元素
        int top_index = st.top();
        st.pop();
        // 处理弹出的元素
    }
    st.push(i);
}
2. 工作原理图解
text
数组: [2, 1, 5, 6, 2, 3]
单调递增栈处理过程：

步骤 栈状态        操作
1     [0]         压入2
2     [1]         1<2，弹出0，压入1
3     [1,2]       5>1，压入2
4     [1,2,3]     6>5，压入3
5     [1,4]       2<6，弹出3；2<5，弹出2；压入4
6     [1,4,5]     3>2，压入5
单调栈的两种类型
1. 单调递增栈
cpp
// 用于寻找"下一个更小元素"
stack<int> increasing_st;
for (int i = 0; i < n; i++) {
    while (!increasing_st.empty() && arr[increasing_st.top()] > arr[i]) {
        // 当前元素arr[i]是栈顶元素的下一个更小元素
        int idx = increasing_st.top();
        increasing_st.pop();
        // 处理：right_smaller[idx] = i
    }
    increasing_st.push(i);
}
适用问题特征
1. 核心特征
需要找到元素的边界位置
单调栈的核心是：**确保了某个元素左面到栈中下一个元素这个区间内一定不会再有比他更大或者更小的元素**
**边界由某种比较条件决定（更大、更小等）**

时间复杂度要求O(n)

2. 典型问题模式
模式1：寻找左右边界
cpp
// 问题：为每个元素找到左右第一个比它小/大的元素
vector<int> left_bound(n), right_bound(n);
stack<int> st;

// 找左边第一个比当前元素小的位置
for (int i = 0; i < n; i++) {
    while (!st.empty() && arr[st.top()] >= arr[i]) {
        st.pop();
    }
    left_bound[i] = st.empty() ? -1 : st.top();
    st.push(i);
}
模式2：计算以某个元素为极值的区间
cpp
// 问题：计算以arr[i]为最小值的最大区间
for (int i = 0; i < n; i++) {
    while (!st.empty() && arr[st.top()] > arr[i]) {
        int idx = st.top();
        st.pop();
        int left = st.empty() ? -1 : st.top();
        // 区间为 (left, i)，以arr[idx]为最小值
        int width = i - left - 1;
        max_area = max(max_area, arr[idx] * width);
    }
    st.push(i);
}
经典应用场景
1. 下一个更大元素系列
cpp
// 问题：找出数组中每个元素的下一个更大元素
vector<int> nextGreaterElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1);
    stack<int> st;
    
    for (int i = 0; i < n; i++) {
        while (!st.empty() && nums[st.top()] < nums[i]) {
            result[st.top()] = nums[i];
            st.pop();
        }
        st.push(i);
    }
    return result;
}
时间复杂度：O(n)
每个元素入栈一次

每个元素出栈一次

总操作次数：2n → O(n)

空间复杂度：O(n)
最坏情况下所有元素都在栈中

思维模式
1. 问题转化思维
将复杂问题转化为"寻找边界"问题：

最大矩形 → 找到每个高度能扩展的左右边界

接雨水 → 找到每个位置左右的最大高度

2. 单调性思维
利用数据的单调性来避免重复计算：

如果 arr[i] < arr[j] 且 i < j，那么对于后面的元素，arr[i] 可能永远不会再被用到

3. 延迟处理思维
栈中存储的是"待定"的元素，等到遇到合适的边界时再统一处理。

总结
单调栈适用于：

需要为每个元素寻找左右边界的问题

边界由大小关系决定的问题

需要O(n)时间复杂度的问题

涉及极值、区间计算的问题

核心思想：利用栈的单调性，在遍历过程中动态维护有用的信息，避免重复计算。

掌握单调栈的关键在于理解其"维护单调性"和"延迟处理"的机制，以及能够识别出问题中的边界查找模式。

