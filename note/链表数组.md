# 适用于对有编号的物品进行移动的需要反复插入和删除的操作

## 例：移动小球
你有一些小球，从左到右依次编号为1,2,3,...,n. 你可以执行两种指令（1或者2）。其中， 1 X Y表示把小球X移动到小球Y的左边， 2 X Y表示把小球X移动到小球Y右边。

指令保证合法，即X不等于Y。 例如，初始状态1,2,3,4,5,6的小球执行1 1 4后，小球1被移动到小球4的左边，即2,3,1,4,5,6。如果再执行2 3 5，结点3将会移到5的右边，即2,1,4,5,3,6。

```
node* arr[500005];
void zuo(int i,int j){
    arr[i]->prev->next=arr[i]->next;
    arr[i]->next->prev=arr[i]->prev;

    arr[j]->prev->next=arr[i];
    arr[i]->prev=arr[j]->prev;
    arr[j]->prev=arr[i];
    arr[i]->next=arr[j];

}

void you(int i,int j){
    arr[i]->prev->next=arr[i]->next;
    arr[i]->next->prev=arr[i]->prev;
    
    arr[j]->next->prev=arr[i];
    arr[i]->next=arr[j]->next;
    arr[j]->next=arr[i];
    arr[i]->prev=arr[j];
    
}

node* arr[20000]//创建的是指针数组
void init(){
for(int i=1;i<=n+1;i++){
            arr[i]=new node(i);
        }
        arr[0]->next=arr[1];
        
        for(int i=1;i<=n+1;i++){
            arr[i]->val=i;
            arr[i]->prev=arr[i-1];
            arr[i]->next=arr[i+1];
        }

}
}
```
**注意事项：**
1. 需要建立头节点和尾节点，方便移动操作
2. 指针必须分配内存，否则会出现未定义行为
