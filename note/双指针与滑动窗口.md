# 双指针
- 双指针可以用来解决线性表问题
- 双指针的初始化既可以是同头，也可以是一头一尾，根据实际情况来定


这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，将枚举的时间复杂度从
$O(N^2)$减少至 O(N)。为什么是 O(N) 呢？这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 O(N)，均摊下来，每次也向左移动一个位置，因此时间复杂度为 O(N)。

# 滑动窗口
**子串问题（连续结构）优先考虑滑动窗口和前缀和，这里使用滑动窗口求解**

**何时想到用滑动窗口？   
当问题具有以下特征时：  
涉及数组/字符串中的连续子序列  
要求找到最大/最小长度、特定和、包含某些元素等   
暴力解法需要多重循环
滑动窗口的优势在于利用先前计算的结果，但回文验证的结果很难在窗口滑动时被有效复用。  
滑动窗口适用于解决连续且具有单调性的问题（如「无重复字符」）**
模板：  
```C++
//外层循环扩展右边界，内层循环扩展左边界
for (int l = 0, r = 0 ; r < n ; r++) {
	//当前考虑的元素
	while (l <= r && check()) {//区间[left,right]不符合题意
        //扩展左边界
    }
    //区间[left,right]符合题意，统计相关信息
}
```
滑动窗口一般要先填满窗口，如果是vector的话，可以用i=0，i++；i+len来访问  
**！！！滑动窗口主要解决的是如果一个序列不合题意，那么向右扩展之后也一定不符合题意的问题**

经典吃糖果例题：
```
#include<iostream>
#include<cmath>
using namespace std;
int arr[200005] = { 0 };

int main() {
  
	int n; int m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		cin >> arr[i];
	}

	int maxsize = 0;
	int tot = 0;
	for (int l = 0, r = 0; r < n; r++) {
		tot += arr[r];
		while (l <= r && tot > m) {
			tot-=arr[l++];
		}
		maxsize = max(maxsize, r - l + 1);
	}
	cout << maxsize;
}
```
