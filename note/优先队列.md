# 在C++中，优先队列（Priority Queue）是一种容器适配器，它提供常数时间的最大元素访问，但在插入和删除时具有对数时间复杂度。默认情况下，优先队列是最大堆。

基本用法
1. 头文件和声明
```cpp
#include <queue>
#include <vector>
#include <functional> // 用于std::greater

// 默认声明（最大堆）
std::priority_queue<int> pq;

// 最小堆声明
std::priority_queue<int, std::vector<int>, std::greater<int>> min_pq;
```
2. 基本操作
```cpp
#include <iostream>
#include <queue>

int main() {
    std::priority_queue<int> pq;
    
    // 插入元素
    pq.push(3);
    pq.push(1);
    pq.push(4);
    pq.push(1);
    pq.push(5);
    
    // 访问顶部元素
    std::cout << "Top element: " << pq.top() << std::endl; // 输出 5
    
    // 删除顶部元素
    pq.pop();
    std::cout << "After pop, top element: " << pq.top() << std::endl; // 输出 4
    
    // 检查是否为空
    std::cout << "Is empty: " << (pq.empty() ? "Yes" : "No") << std::endl;
    
    // 获取大小
    std::cout << "Size: " << pq.size() << std::endl;
    
    return 0;
}
```
**由于删除的始终是栈顶的元素，所以考虑延迟删除的方法，当某一批元素彻底不合格时使用while处理干净**
不同类型的优先队列
```
1. 最小堆
cpp
#include <queue>
#include <vector>
#include <functional>

int main() {
    // 最小堆
    std::priority_queue<int, std::vector<int>, std::greater<int>> min_pq;
    
    min_pq.push(3);
    min_pq.push(1);
    min_pq.push(4);
    min_pq.push(5);
    
    while (!min_pq.empty()) {
        std::cout << min_pq.top() << " ";
        min_pq.pop();
    }
    // 输出: 1 3 4 5
    
    return 0;
}
2. 自定义比较函数
cpp
#include <queue>
#include <vector>

struct Compare {
    bool operator()(int a, int b) {
        // 按照绝对值大小排序，绝对值大的优先级高
        return abs(a) < abs(b);
    }
};

int main() {
    // 使用函数对象
    std::priority_queue<int, std::vector<int>, Compare> abs_pq;
    
    abs_pq.push(-5);
    abs_pq.push(3);
    abs_pq.push(-1);
    abs_pq.push(2);
    
    while (!abs_pq.empty()) {
        std::cout << abs_pq.top() << " ";
        abs_pq.pop();
    }
    // 输出: -5 3 -1 2
    
    return 0;
}
```


# pair
```
pair数据结构详解
1. 什么是pair？
pair是C++标准库中的模板类，用于将两个值组合成一个单元。
```
```cpp
#include <utility> // 或者 <queue>、<vector>等已包含

// 定义方式
pair<int, int> p1;                    // 默认构造
pair<int, string> p2(1, "hello");     // 直接初始化
auto p3 = make_pair(3.14, "world");   // 使用make_pair

// 错误写法
pq.push(pair<nums[i],i>);

// 正确写法
pq.push({nums[i], i});           // C++11及以上
// 或者
pq.push(make_pair(nums[i], i));  // 所有C++版本
// 或者
pq.push(pair<int, int>(nums[i], i));
// 或者
   q.emplace(nums[i], i);//原地创建
```
```
2. pair的成员和操作
cpp
pair<int, int> p(5, 10);

// 访问成员
cout << p.first;   // 输出 5
cout << p.second;  // 输出 10

// 比较操作（按字典序）
pair<int, int> a(1, 2), b(1, 3);
cout << (a < b);  // true，因为1==1，但2<3
为什么优先队列能用pair？
1. pair支持比较操作
cpp
// pair的比较规则：
// 1. 先比较first
// 2. 如果first相等，再比较second

pair<int, int> p1(5, 1), p2(3, 2), p3(5, 3);

// 在最大堆中的顺序：p1(5,1) > p3(5,3) > p2(3,2)
// 因为：5 > 3，且当first相同时，1 < 3但最大堆会保持较大的在前

priority_queue<pair<int, int>> q;
// 这实际上是一个最大堆，比较的是pair本身
// 相当于：priority_queue<pair<int, int>, vector<pair<int, int>>, less<pair<int, int>>>
```
