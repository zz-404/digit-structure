**本质上是找到潜在的递推规律,也就是找到状态转移方程**

# 1.寻找最长公共子串
转移方程：
如果两个字母相同，则以他们为结尾的公共子串长度加1
dp[i][j]=dp[i-1][j-1]+1
否则以他们为结尾的公共子串长度为0

```
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    string s1, s2;
    cin >> s1 >> s2;
    
    int len1 = s1.length();
    int len2 = s2.length();
    
    // 创建二维DP表，dp[i][j]表示以s1[i-1]和s2[j-1]结尾的最长公共子串长度
    vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
    int max_len = 0;
    
    // 填充DP表
    for (int j = 1; j <= len2; j++) {
        for (int i = 1; i <= len1; i++) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
                if (dp[i][j] > max_len) {
                    max_len = dp[i][j];
                }
            } else {
                dp[i][j] = 0;
            }
        }
    }
    
    cout << max_len << endl;
    
    return 0;
}
```
**重点，使用dp[i][j]表示以s1[i-1]和s2[j-1]结尾的最长公共子串长度，优化了边界的问题**


**空间复杂度的优化：针对对角线的二维数组**：
```
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    string s1, s2;
    cin >> s1 >> s2;
    
    int len1 = s1.length();
    int len2 = s2.length();
    
    // 确保s1是较短的字符串，以节省空间
    if (len1 > len2) {
        swap(s1, s2);
        swap(len1, len2);
    }
    
    vector<int> dp(len2, 0);
    int max_len = 0;
    
    for (int i = 0; i < len1; i++) {
        int prev = 0;//必须更新因为边界处prev应该等于0
        for (int j = 0; j < len2; j++) {
            int temp = dp[j];
            if (s1[i] == s2[j]) {
                dp[j] = prev + 1;
                if (dp[j] > max_len) {
                    max_len = dp[j];
                }
            } else {
                dp[j] = 0;
            }
            prev = temp;
        }
    }
    
    cout << max_len << endl;
    
    return 0;
}
```
通过temp保存还未更新的数组（即上一行），再赋值给prev留给下一个数用
